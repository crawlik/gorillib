# Hashlike#==
#
# Equality -- Two hashes are equal if they have the same default value, they
# contain the same number of keys, and the value corresponding to each key in
# the first hash is equal (using ==) to the value for the same key in the
# second. If obj is not a hash, attempt to convert it using to_hash and return
# obj == +hsh+.
#
# @example
#     h1 = { :a => 1, :c => 2 }
#     h2 = { 7 => 35, :c => 2, :a => 1 }
#     h3 = { :a => 1, :c => 2, 7 => 35 }
#     h4 = { :a => 1, :d => 2, :f => 35 }
#     h1 == h2 # => false
#     h2 == h3 # => true
#     h3 == h4 # => false
#

# Hashlike#[]
#
# Element Reference -- Retrieves the value stored for +key+.
#
# In a normal hash, a default value can be set; none is provided here.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh[:a] # => 100
#     hsh[:c] # => nil
#
# @param  key [Object] key to retrieve
# @return [Object] the value stored for key, nil if missing
#

# Hashlike#[]=
# Hashlike#store
#
# Element Assignment -- Associates the value given by value with the key given
# by +key+.
#
# key should not have its value changed while it is in use as a key. In a
# normal hash, a String passed as a key will be duplicated and frozen. No such
# guarantee is provided here
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh[:a] = 9
#     hsh[:c] = 4
#     hsh    # => { :a => 9, :b => 200, :c => 4 }
#
#     hsh[key] = val                         -> val
#     hsh.store(key, val)                    -> val
#
# @param  key [Object] key to associate
# @param  val [Object] value to associate it with
# @return [Object]
#


# Hashlike#delete
#
# Deletes and returns the value from +hsh+ whose key is equal to +key+. If the
# optional code block is given and the key is not found, pass in the key and
# return the result of +block+.
#
# In a normal hash, a default value can be set; none is provided here.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.delete(:a)                            # => 100
#     hsh.delete(:z)                            # => nil
#     hsh.delete(:z){|el| "#{el} not found" }   # => "z not found"
#
# @overload hsh.delete(key)                  -> val
#   @param  key [Object] key to remove
#   @return [Object, Nil] the removed object, nil if missing
#
# @overload hsh.delete(key){|key| block }    -> val
#   @param  key [Object] key to remove
#   @yield  [Object] called (with key) if key is missing
#   @yieldparam key
#   @return [Object, Nil] the removed object, or if missing, the return value
#     of the block
#


# Hashlike#keys
#
# Returns a new array populated with the keys from this hashlike.
#
# @see Hashlike#values.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300, :d => 400 }
#     hsh.keys   # => [:a, :b, :c, :d]
#
# @return [Array] list of keys
#


# Hashlike#each
#
# Calls +block+ once for each key in +hsh+, passing the key-value pair as
# parameters.
#
# If no block is given, an enumerator is returned instead.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.each{|key, value| puts "#{key} is #{value}" }
#     # produces:
#     a is 100
#     b is 200
#
# @overload hsh.each{|key, val| block }      -> hsh
#   Calls block once for each key in +hsh+
#   @yield [key, val] in order, each key and its associated value
#   @return [Hashlike]
#
# @overload hsh.each                         -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#each_key
#
# Calls +block+ once for each key in +hsh+, passing the key as a parameter.
#
# If no block is given, an enumerator is returned instead.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.each_key{|key| puts key }
#     # produces:
#     a
#     b
#
# @overload hsh.each_key{|key| block }       -> hsh
#   Calls +block+ once for each key in +hsh+
#   @yield [key] in order, each key
#   @return [Hashlike]
#
# @overload hsh.each_key                     -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#each_value
#
# Calls +block+ once for each key in +hsh+, passing the value as a parameter.
#
# If no block is given, an enumerator is returned instead.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.each_value{|value| puts value }
#     # produces:
#     100
#     200
#
# @overload hsh.each_value{|val| block }     -> hsh
#   Calls +block+ once for each value in +hsh+
#   @yield [val] in order by its key, each value
#   @return [Hashlike]
#
# @overload hsh.each_value                   -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#has_key?
#
# Returns true if the given key is present in +hsh+.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_key?(:a)   # => true
#     hsh.has_key?(:z)   # => false
#
# @param key [Object] the key to query
# @return [true, false] true if the key is present, false otherwise
#


# Hashlike#include?
#
# Returns true if the given key is present in +hsh+.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_key?(:a)   # => true
#     hsh.has_key?(:z)   # => false
#
# @param key [Object] the key to query
# @return [true, false] true if the key is present, false otherwise
#


# Hashlike#key?
#
# Returns true if the given key is present in +hsh+.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_key?(:a)   # => true
#     hsh.has_key?(:z)   # => false
#
# @param key [Object] the key to query
# @return [true, false] true if the key is present, false otherwise
#


# Hashlike#member?
#
# Returns true if the given key is present in +hsh+.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_key?(:a)   # => true
#     hsh.has_key?(:z)   # => false
#
# @param key [Object] the key to query
# @return [true, false] true if the key is present, false otherwise
#


# Hashlike#has_value?
#
# Returns true if the given value is present for some key in +hsh+.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_value?(100)   # => true
#     hsh.has_value?(999)   # => false
#
# @param  val [Object] the value to query
# @return [true, false] true if the value is present, false otherwise
#


# Hashlike#value?
#
# Returns true if the given value is present for some key in +hsh+.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_value?(100)   # => true
#     hsh.has_value?(999)   # => false
#
# @param  val [Object] the value to query
# @return [true, false] true if the value is present, false otherwise
#


# Hashlike#fetch
#
# Returns a value from the hashlike for the given key. If the key can't be
# found, there are several options:
# * With no other arguments, it will raise a +KeyError+ exception;
# * if default is given, then that will be returned;
# * if the optional code block is specified, then that will be run and its result returned.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.fetch(:a)                          # => 100
#     hsh.fetch(:z, "go fish")               # => "go fish"
#     hsh.fetch(:z){|el| "go fish, #{el}"}   # => "go fish, z"
#
# @example An exception is raised if the key is not found and a default value is not supplied.
#     hsh = { :a => 100, :b => 200 }
#     hsh.fetch(:z)
#     # produces:
#     prog.rb:2:in `fetch': key not found (KeyError) from prog.rb:2
#
#     hsh.fetch(:z, 3)
#     # => 3
#
#     hsh.fetch(:z){|key| key.to_s * 5 }
#     # => "zzzzz"
#
# @param key     [Object]   the key to query
# @param default [Object]   the value to use if the key is missing
# @raise         [KeyError] raised if missing, and neither +default+ nor +block+ is supplied
# @yield         [key]      if missing, block called with the key requested
# @return        [Object]   the value; if missing, the default; if missing, the
#                           block's return value
#


# Hashlike#length
#
# Returns the number of key-value pairs in the hashlike.
#
# @example
#     hsh = { :d => 100, :a => 200, :v => 300, :e => 400 }
#     hsh.length       # => 4
#     hsh.delete(:a)   # => 200
#     hsh.length       # => 3
#
# @return [Fixnum] number of key-value pairs
#


# Hashlike#empty?
#
# Returns true if the hashlike contains no key-value pairs.
#
# @example
#     {}.empty?   # => true
#
# @return [true, false] true if +hsh+ contains no key-value pairs, false otherwise
#


# Hashlike#to_hash
#
# Returns a hash with each key set to its associated value.
#
# @example
#    my_hshlike = MyHashlike.new
#    my_hshlike[:a] = 100; my_hshlike[:b] = 200
#    my_hshlike.to_hash # => { :a => 100, :b => 200 }
#
# @return [Hash] a new Hash instance, with each key set to its associated value.
#


# Hashlike#values
#
# Returns a new array populated with the values from +hsh+.
#
# @see Hashlike#keys.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.values   # => [100, 200, 300]
#
# @return [Array] the values, in order by their key.
#


# Hashlike#values_at
#
# Return an array containing the values associated with the given keys.
#
# @see Hashlike#select.
#
# @example
#     hsh = { "cat" => "feline", "dog" => "canine", "cow" => "bovine" }
#     hsh.values_at("cow", "cat")  # => ["bovine", "feline"]
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.values_at(:c, :a, :c, :z, :a)
#     # => [300, 100, 300, nil, 100]
#
# @param  *allowed_keys [Object] the keys to retrieve.
# @return [Array] the values, in order according to allowed_keys.
#


# Hashlike#key
#
# Searches the hash for an entry whose value == value, returning the
# corresponding key. If multiple entries has this value, the key returned will
# be that of one of the entries (unpredictably). If not found, returns +nil+.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.key(200)   # => :b
#     hsh.key(999)   # => nil
#
# @param  val [Object] the value to look up
# @return [Object, nil] the key for the given val, or nil if missing
#


# Hashlike#invert
#
# Returns a new hash created by using +hsh+'s values as keys, and the keys as
# values. If +hsh+ has duplicate values, the result will contain only one of
# them as a key -- which one is not predictable.
#
# @example
#     hsh = { :n => 100, :m => 100, :y => 300, :d => 200, :a => 0 }
#     hsh.invert # => { 0 => :a, 100 => :m, 200 => :d, 300 => :y }
#
# @return [Hash] a new hash, with values for keys and vice-versa
#


# Hashlike#delete_if
#
# Deletes every key-value pair from +hsh+ for which +block+ evaluates
# to true.
#
# If no block is given, an enumerator is returned instead.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.delete_if{|key, val| key.to_s >= "b" }   # => { :a => 100 }
#
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.delete_if{|key, val| key.to_s >= "z" }   # => { :a => 100, :b => 200, :c => 300 }
#
# @overload hsh.delete_if{|key, val| block } -> hsh
#   Deletes every key-value pair from +hsh+ for which +block+ evaluates to true.
#   @return [Hashlike]
#
# @overload hsh.delete_if                    -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#reject!
#
# Deletes every key-value pair from +hsh+ for which +block+ evaluates to true.
# (Equivalent to Hashlike#delete_if), but returns nil if no changes were made.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.delete_if{|key, val| key.to_s >= "b" }   # => { :a => 100 }
#
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.delete_if{|key, val| key.to_s >= "z" }   # nil
#
# @overload hsh.reject!{|key, val| block }   -> hsh or nil
#   Deletes every key-value pair from +hsh+ for which +block+ evaluates to true.
#   @return [Hashlike, nil]
#
# @overload hsh.reject!                      -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#reject
#
# Same as Hashlike#delete_if, but works on (and returns) a copy of the
# +hsh+. Equivalent to <tt>hsh.dup.delete_if<tt>.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.reject{|key, val| key.to_s >= "b" }   # => { :a => 100 }
#     hsh # => { :a => 100, :b => 200, :c => 300 }
#
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.reject{|key, val| key.to_s >= "z" }   # => { :a => 100, :b => 200, :c => 300 }
#     hsh # => { :a => 100, :b => 200, :c => 300 }
#
# @overload hsh.reject{|key, val| block }    -> new_hashlike
#   Deletes every key-value pair from +hsh+ for which +block+ evaluates to true.
#   @return [Hashlike]
#
# @overload hsh.reject                       -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#keep_if
#
# Deletes every key-value pair from +hsh+ for which +block+ evaluates to false.
#
# If no block is given, an enumerator is returned instead.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.keep_if{|key, val| key.to_s >= "b" }   # => { :b => 200, :c => 300 }
#
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.keep_if{|key, val| key.to_s >= "a" }   # => { :a => 100, :b => 200, :c => 300 }
#
# @overload hsh.keep_if{|key, val| block }   -> hsh
#   Deletes every key-value pair from +hsh+ for which +block+ evaluates to false.
#   @return [Hashlike]
#
# @overload hsh.keep_if                      -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#select!
#
# Equivalent to Hashlike#keep_if, but returns nil if no changes were
# made.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.select!{|key, val| key.to_s >= "b" }   # => { :b => 200, :c => 300 }
#
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.select!{|key, val| key.to_s >= "a" }   # => { :a => 100, :b => 200, :c => 300 }
#
# @overload hsh.select!{|key, val| block }   -> hsh or nil
#   Deletes every key-value pair from +hsh+ for which +block+ evaluates to false.
#   @return [Hashlike]
#
# @overload hsh.select!                      -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#clear
#
# Removes all key-value pairs from +hsh+.
#
# @example
#     hsh = { :a => 100, :b => 200 }   # => { :a => 100, :b => 200 }
#     hsh.clear                        # => {}
#
# @return [Hashlike] this hashlike, emptied
#


# Hashlike#assoc
#
# Searches through the hashlike comparing obj with the key using ==.
# Returns the key-value pair (two elements array) or nil if no match is
# found.
#
# @see Array#assoc.
#
# @example
#     hsh = { "colors"  => ["red", "blue", "green"],
#             "letters" => [:a, :b, :c ]}
#     hsh.assoc("letters")  # => ["letters", [:a, :b, :c]]
#     hsh.assoc("foo")      # => nil
#
# @return [Array, nil] the key-value pair (two elements array) or nil if no
#   match is found.
#


# Hashlike#rassoc
#
# Searches through the hashlike comparing obj with the value using ==.
# Returns the first key-value pair (two-element array) that matches.
#
# @see Array#rassoc.
#
# @example
#     hsh = { 1 => "one", 2 => "two", 3 => "three", "ii" => "two"}
#     hsh.rassoc("two")    # => [2, "two"]
#     hsh.rassoc("four")   # => nil
#
# @return [Array, nil] The first key-value pair (two-element array) that
#   matches, or nil if no match is found
#


# Hashlike#flatten
#
# Returns a new array that is a one-dimensional flattening of this hashlike. That
# is, for every key or value that is an array, extract its elements into the
# new array.  Unlike Array#flatten, this method does not flatten recursively
# by default.  The optional level argument determines the level of recursion
# to flatten.
#
# @example
#     hsh =  {1=> "one", 2 => [2,"two"], 3 => "three"}
#     hsh.flatten    # => [1, "one", 2, [2, "two"], 3, "three"]
#     hsh.flatten(2) # => [1, "one", 2, 2, "two", 3, "three"]
#
# @example
#     hsh = { [1, 2, [3, 4]] => [1, [2, 3, [4, 5, 6]]] }
#     hsh.flatten
#     # =>   [[1, 2, [3, 4]],   [1, [2, 3, [4, 5, 6]]]]
#     hsh.flatten(0)
#     # =>  [[[1, 2, [3, 4]],   [1, [2, 3, [4, 5, 6]]]]]
#     hsh.flatten(1)
#     # =>   [[1, 2, [3, 4]],   [1, [2, 3, [4, 5, 6]]]]
#     hsh.flatten(2)
#     # =>    [1, 2, [3, 4],     1, [2, 3, [4, 5, 6]]]
#     hsh.flatten(3)
#     # =>    [1, 2,  3, 4,      1,  2, 3, [4, 5, 6]]
#     hsh.flatten(4)
#     # =>    [1, 2,  3, 4,      1,  2, 3,  4, 5, 6]
#
# @param  level [Integer] the level of recursion to flatten, 0 by default.
# @return [Array] the flattened key-value array.
#


# Hashlike#update
#
# Adds the contents of +other_hash+ to +hsh+.  If no block is
# specified, entries with duplicate keys are overwritten with the values from
# +other_hash+, otherwise the value of each duplicate key is determined by
# calling the block with the key, its value in +hsh+ and its value in
# +other_hash+.
#
# @example
#     h1 = { :a => 100, :b => 200 }
#     h2 = { :b => 254, :c => 300 }
#     h1.merge!(h2)
#     # => { :a => 100, :b => 254, :c => 300 }
#
#     h1 = { :a => 100, :b => 200 }
#     h2 = { :b => 254, :c => 300 }
#     h1.merge!(h2){|key, v1, v2| v1 }
#     # => { :a => 100, :b => 200, :c => 300 }
#
# @overload hsh.update(other_hash)                               -> hsh
#   Adds the contents of +other_hash+ to +hsh+.  Entries with duplicate keys are
#   overwritten with the values from +other_hash+
#   @param  other_hash [Hash, Hashlike] the hash to merge (it wins)
#   @return [Hashlike] this hashlike, updated
#
# @overload hsh.update(other_hash){|key, oldval, newval| block}  -> hsh
#   Adds the contents of +other_hash+ to +hsh+.  The value of each duplicate key
#   is determined by calling the block with the key, its value in +hsh+ and its
#   value in +other_hash+.
#   @param  other_hash [Hash, Hashlike] the hash to merge (it wins)
#   @yield  [Object, Object, Object] called if key exists in each +hsh+
#   @return [Hashlike] this hashlike, updated
#


# Hashlike#merge
#
# Returns a new hashlike containing the contents of +other_hash+ and the
# contents of +hsh+. If no block is specified, the value for entries with
# duplicate keys will be that of +other_hash+. Otherwise the value for each
# duplicate key is determined by calling the block with the key, its value in
# +hsh+ and its value in +other_hash+.
#
# @example
#     h1 = { :a => 100, :b => 200 }
#     h2 = { :b => 254, :c => 300 }
#     h1.merge(h2)
#     # => { :a=>100, :b=>254, :c=>300 }
#     h1.merge(h2){|key, oldval, newval| newval - oldval}
#     # => { :a => 100, :b => 54,  :c => 300 }
#     h1
#     # => { :a => 100, :b => 200 }
#
# @overload hsh.merge(other_hash)                               -> hsh
#   Adds the contents of +other_hash+ to +hsh+.  Entries with duplicate keys are
#   overwritten with the values from +other_hash+
#   @param  other_hash [Hash, Hashlike] the hash to merge (it wins)
#   @return [Hashlike] a new merged hashlike
#
# @overload hsh.merge(other_hash){|key, oldval, newval| block}  -> hsh
#   Adds the contents of +other_hash+ to +hsh+.  The value of each duplicate key
#   is determined by calling the block with the key, its value in +hsh+ and its
#   value in +other_hash+.
#   @param  other_hash [Hash, Hashlike] the hash to merge (it wins)
#   @yield  [Object, Object, Object] called if key exists in each +hsh+
#   @return [Hashlike] a new merged hashlike
#
